# -*- coding: utf-8 -*-

"""
kay.utils.datastructures
~~~~~~~~~~~~~~~~~~~~~~~~~

Various data structures.

:Copyright: (c) 2009 Accense Technology, Inc. All rights reserved.
:copyright: (c) 2009 by the Zine Team, see AUTHORS for more details.
:license: BSD, see LICENSE for more details.

This file originally derives from Zine project.
"""

from itertools import izip, imap
from copy import deepcopy


class _Missing(object):

  def __reduce__(self):
    return 'missing'

  def __repr__(self):
    return 'no default'

missing = _Missing()
del _Missing


class ReadOnlyMultiMapping(object):
  """Provides a read only view to multiple mappings."""

  def __init__(self, *mappings):
    self.__dict__['mappings'] = mappings

  @property
  def mappings(self):
    """The tuple of mappings this multi mapping looks up."""
    return self.__dict__['mappings']

  def __getitem__(self, name):
    for mapping in self.mappings:
      if name in mapping:
        return mapping[name]
    raise KeyError(name)

  def get(self, name, default=None):
    """Return a key or the default value if no value exists."""
    try:
      return self[name]
    except KeyError:
      return default

  def __contains__(self, name):
    try:
      self[name]
    except KeyError:
      return False
    return True

  def _dict_method(name):
    def proxy(self):
      return getattr(self.as_dict(), name)()
    proxy.__name__ = name
    proxy.__doc__ = getattr(dict, name).__doc__
    return proxy

  __iter__ = iterkeys = _dict_method('iterkeys')
  itervalues = _dict_method('itervalues')
  iteritems = _dict_method('iteritems')
  keys = _dict_method('keys')
  values = _dict_method('values')
  items = _dict_method('items')
  __len__ = _dict_method('__len__')
  del _dict_method

  def as_dict(self):
    result = {}
    for mapping in reversed(self.mappings):
      result.update(mapping)
    return result


class _PickleProtocol2Sucks(object):
  """This class implements a dummy container that just eats up all
  the stuff appended to it.  It exists because pickle protocol 2 feeds
  stuff to the ordered dict with opcodes *before* `__setstate__` is
  called.  As a matter of fact no `_keys` is present on the dict that point
  and the unpickling crashes with an `AttributeError`.

  This behavior is confusing and yet undocumented, see `#4612`_.

  .. _#4612: http://bugs.python.org/issue4712
  """

  def append(self, value):
    pass


class OrderedDict(dict):
  """Simple ordered dict implementation.

  It's a dict subclass and provides some list functions.  The implementation
  of this class is inspired by the implementation of Babel but incorporates
  some ideas from the `ordereddict`_ and Django's ordered dict.

  The constructor and `update()` both accept iterables of tuples as well as
  mappings:

  >>> d = OrderedDict([('a', 'b'), ('c', 'd')])
  >>> d.update({'foo': 'bar'})
  >>> d
  OrderedDict([('a', 'b'), ('c', 'd'), ('foo', 'bar')])

  Keep in mind that when updating from dict-literals the order is not
  preserved as these dicts are unsorted!

  You can copy an OrderedDict like a dict by using the constructor, `copy.copy`
  or the `copy` method and make deep copies with `copy.deepcopy`:

  >>> from copy import copy, deepcopy
  >>> copy(d)
  OrderedDict([('a', 'b'), ('c', 'd'), ('foo', 'bar')])
  >>> d.copy()
  OrderedDict([('a', 'b'), ('c', 'd'), ('foo', 'bar')])
  >>> OrderedDict(d)
  OrderedDict([('a', 'b'), ('c', 'd'), ('foo', 'bar')])
  >>> d['spam'] = []
  >>> d2 = deepcopy(d)
  >>> d2['spam'].append('eggs')
  >>> d
  OrderedDict([('a', 'b'), ('c', 'd'), ('foo', 'bar'), ('spam', [])])
  >>> d2
  OrderedDict([('a', 'b'), ('c', 'd'), ('foo', 'bar'), ('spam', ['eggs'])])

  All iteration methods as well as `keys`, `values` and `items` return
  the values ordered by the the time the key-value pair is inserted:

  >>> d.keys()
  ['a', 'c', 'foo', 'spam']
  >>> d.values()
  ['b', 'd', 'bar', []]
  >>> d.items()
  [('a', 'b'), ('c', 'd'), ('foo', 'bar'), ('spam', [])]
  >>> list(d.iterkeys())
  ['a', 'c', 'foo', 'spam']
  >>> list(d.itervalues())
  ['b', 'd', 'bar', []]
  >>> list(d.iteritems())
  [('a', 'b'), ('c', 'd'), ('foo', 'bar'), ('spam', [])]

  Index based lookup is supported too by `byindex` which returns the
  key/value pair for an index:

  >>> d.byindex(2)
  ('foo', 'bar')

  You can reverse the OrderedDict as well:

  >>> d.reverse()
  >>> d
  OrderedDict([('spam', []), ('foo', 'bar'), ('c', 'd'), ('a', 'b')])

  And sort it like a list:

  >>> d.sort(key=lambda x: x[0].lower())
  >>> d
  OrderedDict([('a', 'b'), ('c', 'd'), ('foo', 'bar'), ('spam', [])])

  .. _proposal: http://thread.gmane.org/gmane.comp.python.devel/95316
  .. _ordereddict: http://www.xs4all.nl/~anthon/Python/ordereddict/
  """
  _keys = _PickleProtocol2Sucks()

  def __init__(self, *args, **kwargs):
    dict.__init__(self)
    self._keys = []
    self.update(*args, **kwargs)

  def __delitem__(self, key):
    dict.__delitem__(self, key)
    self._keys.remove(key)

  def __setitem__(self, key, item):
    if key not in self:
      self._keys.append(key)
    dict.__setitem__(self, key, item)

  def __deepcopy__(self, memo=None):
    if memo is None:
      memo = {}
    d = memo.get(id(self), missing)
    if d is not missing:
      return d
    memo[id(self)] = d = self.__class__()
    dict.__init__(d, deepcopy(self.items(), memo))
    d._keys = self._keys[:]
    return d

  def __getstate__(self):
    return {'items': dict(self), 'keys': self._keys}

  def __setstate__(self, d):
    self._keys = d['keys']
    dict.update(self, d['items'])

  def __reversed__(self):
    return reversed(self._keys)

  def __eq__(self, other):
    if isinstance(other, OrderedDict):
      if not dict.__eq__(self, other):
        return False
      return self.items() == other.items()
    return dict.__eq__(self, other)

  def __ne__(self, other):
    return not self.__eq__(other)

  def __cmp__(self, other):
    if isinstance(other, OrderedDict):
      return cmp(self.items(), other.items())
    elif isinstance(other, dict):
      return dict.__cmp__(self, other)
    return NotImplemented

  @classmethod
  def fromkeys(cls, iterable, default=None):
    return cls((key, default) for key in iterable)

  def clear(self):
    del self._keys[:]
    dict.clear(self)

  def copy(self):
    return self.__class__(self)

  def items(self):
    return zip(self._keys, self.values())

  def iteritems(self):
    return izip(self._keys, self.itervalues())

  def keys(self):
    return self._keys[:]

  def iterkeys(self):
    return iter(self._keys)

  def pop(self, key, default=missing):
    if default is missing:
      return dict.pop(self, key)
    elif key not in self:
      return default
    self._keys.remove(key)
    return dict.pop(self, key, default)

  def popitem(self, key):
    self._keys.remove(key)
    return dict.popitem(self, key)

  def setdefault(self, key, default=None):
    if key not in self:
      self._keys.append(key)
    dict.setdefault(self, key, default)

  def update(self, *args, **kwargs):
    sources = []
    if len(args) == 1:
      if hasattr(args[0], 'iteritems'):
        sources.append(args[0].iteritems())
      else:
        sources.append(iter(args[0]))
    elif args:
      raise TypeError('expected at most one positional argument')
    if kwargs:
      sources.append(kwargs.iteritems())
    for iterable in sources:
      for key, val in iterable:
        self[key] = val

  def values(self):
    return map(self.get, self._keys)

  def itervalues(self):
    return imap(self.get, self._keys)

  def index(self, item):
    return self._keys.index(item)

  def byindex(self, item):
    key = self._keys[item]
    return (key, dict.__getitem__(self, key))

  def reverse(self):
    self._keys.reverse()

  def sort(self, cmp=None, key=None, reverse=False):
    if key is not None:
      self._keys.sort(key=lambda k: key((k, self[k])))
    elif cmp is not None:
      self._keys.sort(lambda a, b: cmp((a, self[a]), (b, self[b])))
    else:
      self._keys.sort()
    if reverse:
      self._keys.reverse()

  def __repr__(self):
    return '%s(%r)' % (type(self).__name__, self.items())

  __copy__ = copy
  __iter__ = iterkeys
